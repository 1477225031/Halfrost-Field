# HTTPS 温故知新（二） —— 非对称加密


<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_0.png'>
</p>


## 一、引子

在对称加密中，例如一次性密码本，就存在密钥配送的问题。在 DES、AES 中也存在这个问题。由于加密和解密的密钥是相同的，所以必须向接收者配送密钥。如果使用公钥密钥，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送的问题，可以说公钥密码是密码学历史上最伟大的发明。


## 二、配送密钥问题

为了防止中间人截获密钥，安全的把密钥传递给通信对方。有以下 4 种方式：

### 1. 事先共享密钥

这种方法虽然有效，但是具有局限性。在一次性密码本中，我们说过，大国之间的热线是用这种方式加密的，但是密钥是靠特工押送过去的。如果通讯对方在附近，提前共享密钥还比较方便。如果通讯对方在世界各地，这种方式也就存在局限性了。

另外通讯量增大以后，密钥个数也会陡增。n 个人两两通讯，需要 n * (n-1) /2 个密钥。这点来看，也不现实。

### 2. 密钥分配中心

为了解决事先共享密钥的密钥增多的问题。于是有人想出了密钥分配中心(Key Distribution Center, KDC)的办法。每次加密的密钥由密钥中心进行分配，每个人只要和密钥中心事先共享密钥就可以了。

虽然这个方法解决了密钥增多的问题，但是又带来了新的问题。

密钥中心存储和记录了所有的密钥，一旦它出现故障或者被攻击破坏，那么所有的加密都会瘫痪。这也是集中式管理的缺点。


### 3. Diffie-Hellman 密钥交换

为了解决集中式管理的缺点，那么应该密钥的配送还是不能用集中式。于是有人想出了 Diffie-Hellman 密钥交换的方法。

在 Diffie-Hellman 密钥交换中，加密通信双方需要交换一些信息，而这些信息即便被窃听者窃听，也不会有任何问题。

根据交换的信息，双方各自生成相同的密钥。而窃听者无法生成相同的密钥。这种方式可行。不过这种方式不算是非对称加密，在本文中不详细讨论。

### 4. 公钥密码

非对称加密有一个公钥和一个私钥。公钥可以在网上传播，被窃听者拿到也没有关系，由于没有私钥，他也无法解开密文。私钥只要掌握在接收者手上就不会导致密文被窃听。

举个例子：超市里面的存包处，所有顾客有硬币就可以存包。硬币就是“公钥”，顾客把包放进箱子里，（明文加密），箱子锁上以后就没人能打开。这个时候窃听者也拿不走存进去的包。这个明文（包），只有私钥才能打开。客户存完包以后会生成一个私钥，只要这个钥匙在手，就可以随时开箱拿包。


## 三、非对称加密

非对称加密一般指的是具有公钥密钥(public-key cryptography)的加密算法。密钥分为加密密钥和解密密钥两种。发送者用加密密钥对信息进行加密，接收者用解密密钥对密文进行解密。可以公开出去的叫公钥(public key)，保存在自己手上不公开的叫私钥(private key)。

公钥和私钥是一一对应的。一对公钥和私钥统称为密钥对(key pair)。在数学的关系上，这两者不能单独生成。


## 四、非对称加密存在的问题

公钥密码虽然解决了密钥配送的问题，但是并不意味着它解决了所有问题。公钥密码存在以下几个问题：

- 公钥认证
- 处理速度不到对称加密的十分之一

## 五、RSA 算法流程

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_3.png'>
</p>


RSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、Adi Shamir 和 Leonard Adleman 的姓氏的首字母组成的 (Rivest-Shamir-Adleman)。1983 年，RSA 公司为 RSA 算法在美国取得了权利，但是现在该专利已经过期了。

RSA 可以被用于公钥密码和数字签名。

### 1. RSA 加密

在 RSA 中，明文、密钥和密文都是数字。加密过程可以用下面的公式来表示：

```c
密文 = 明文^E mod N
```

RSA 的密文是对代表明文的数字 E 次方求 mod N 的结果。E 和 N 是 RSA 加密的密钥，**E 和 N 的组合就是公钥**。E 是加密 Encryption 的首字母，N 是数字 Number 的首字母。


### 2. RSA 解密

RSA 解密过程可以用下面的公式来表示：

```c
明文 = 密文^D mod N
```

解密的过程是对密文的数字的 D 次方求 mod N 就可以得到明文。**D 和 N 的组合就是私钥**。D 是解密 Decryption 的首字母，N 是数字 Number 的首字母。

RSA 奇妙的是加密和解密过程是一致的。加密是求明文的 E 次方对 N 的 mod 余数。解密是求密文的 D 次方对 N 的 mod 余数。

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_2.png'>
</p>


### 3. 生成密钥对

E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 的这三个数是**生成密钥对**。具体流程主要分为 4 步：

- 求 N
- 求 L(L 是仅在生成密钥对的过程中使用的数)
- 求 E
- 求 D

主要步骤如下图：

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_5.png'>
</p>

先计算 N。

计算 N 需要准备 2 个很大的质数。质数太小容易被破译，太大导致计算时间很长。p 和 q 都是由伪随机数生成器生成的，且 p != q。N = p * q。

再计算 L。

L 这个数只在生成密钥对的过程中会用到，加密和解密过程中都不出现。
L 是 p - 1 和 q - 1 的最小公倍数 (least common multiple, lcm)。

再求数 E。

数 E 需要满足两个条件：

```c
1 < E < L

gcd(E,L) = 1 ， E 和 L 的最大公约数为 1 (E 和 L 互质)
```

条件 1 用伪随机生成树生成。条件 2 是为了保证一定存在解密时需要使用的数 D。求最大公约数可以使用欧几里得的辗转相除法。

至次，我们已经生成了密钥对中的公钥{E,M}

再求 D。

数 D 是由数 E 计算得到的。D、E、L 之间具有以下的关系：

```c
1 < D < L

E * D mod L = 1
```

只要 D 满足上面的条件，就可以通过 E 和 N 进行加密的密文，可以通过 D 和 N 进行解密。要保证一定存在满足条件的 D，需要先保证 E 和 L 的最大公约数为 1 。`E * D mod L = 1` 这个条件保证了密文解密以后可以得到明文。


<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_6_.png'>
</p>

## 六、直接攻击 RSA

要想直接攻击 RSA，也就是拿到密文算出明文。我们知道：

```c
密文 = 明文^E mod N
```

攻击者可以拿到密文和公钥{E,N}。那么现在问题转变成求离散对数的问题。目前还没有针对这个问题的高效算法。所以这条路走不通。

换一个思路，算出私钥，通过解密的方式顺序计算出明文。现在公钥里面有 N，私钥还需要知道 D，那么能暴力计算出 D 么？

一般 p 和 q 的长度都在 1024 位以上，N 的长度在 2048 以上。D 的长度 和 N 差不多，那么需要进行 2048 位以上的破解，在现实的时间内破解也是极其困难的。(除非以后量子计算机出现，当然量子计算机出现，当前现有加密体系也会被全部颠覆)

既然暴力破解 D 是不可能的，那么通过 E 和 N 计算 D 可行么？整理一下可以推暴力计算 D 的现有条件：

```c
E * D mod L = 1

N = p * q

L = lcm( p-1 , q-1)

```

目前我们知道 E 和 N，想算出 D 需要先算出 L，而 L 和 p、q 有关系。 p * q 又恰恰等于 N。那么我们第一步需要先破译 p 和 q。

目前对大数 N 进行质因数分解，比较难。**一旦发现了能对大整数进行质因数分解的高效算法，RSA 也就能够被破译**。目前还没有有效的算法。想通过猜测来推出 p、q 也不可能。p、q 的位数一般会比较长。

**p、q 两者在 RSA 中的地位和私钥的地位是一样的，一旦 p、q 被泄露，也就相当于私钥被泄露了**。



## 七、间接攻击 RSA

间接攻击 RSA 指的是利用中间人攻击。

举个例子，如下图：


<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_7.png'>
</p>

主动攻击者 Mallory 在通信双方之间拦截各自的公钥。并且分别向两者发送自己的公钥。这样攻击者就可以在中间截获两边的密文，并且用自己的私钥进行解密。解密得到明文以后就可以任意篡改原文。最终达到攻击的目的。


这种攻击仅仅靠 RSA 本身是无法防御的。要想防御中间人攻击需要用到认证相关的算法。认证相关的算法在下一篇文章里面再详细说明。


## 八、椭圆曲线加密算法

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_16.webp'>
</p>

椭圆曲线密码(Elliptic Curve Cryptography, ECC)是近期备受关注的公钥密码算法。它的特点是比 RSA 所需的密钥长度短。**椭圆曲线密码密钥短但强度高**。密钥长度 224 - 255 比特的椭圆曲线密码，与密钥长度为 2048 比特的 RSA 具备相同的长度。

对应关系如下：

|RSA Key Length (bit)	| ECC Key Length (bit)|
|:-----:|:-----:|
|1024	 |160|
|2048	|224|
|3072	|256|
|7680	|384|
|15360|	521|


椭圆曲线源自于求椭圆弧长的椭圆积分的反函数。一般情况下，椭圆曲线可以用下面的方程式来表示，其中 a,b,c,d 为系数：

```c
E: y^2 = ax^3 + bx^2 + cx+ d
```

举个例子，

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_8.png'>
</p>

上面是一条椭圆曲线，但是它的样子也并不是一个椭圆。

### 1. 椭圆曲线上的运算

加法运算：椭圆曲线上的两点 A 和 B，构成的直线与椭圆曲线的交点，与 X 轴的对称点，定义为 A+B。如下图： 

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_9.png'>
</p>

当然也存在两个点重合的情况，这种情况下，就相当于寻找 2 倍点的问题。在椭圆曲线上的一点 A，做一条切线，与椭圆曲线的另外一交点，相对于 X 轴的对称点成为 2 倍点。这种运算成为 2 倍计算，如下图：

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_10.png'>
</p>

点 A 相对于 X 轴的对称位置的点成为 -A。这个运算成为椭圆曲线的正负取反运算。如下图：

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_11.png'>
</p>


### 2. 椭圆曲线加密实质

椭圆曲线
<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_17.gif'>
</p>


<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_18.png'>
</p>


<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleImage/101_12.png'>
</p>









## 九、其他公钥加密算法

EIGamal 方式是由 Taher EIGamal 设计的公钥算法。RSA 利用了质因数分解的困难度，而 EIGamal 利用了 mod N 下求离散对数的困难度。

EIGamal 方式有一个缺点，就是经过加密的密文长度会变成明文的 2 倍。密码软件 GnuPG 中就支持这种方式。

Rabin 方式是由 M.O.Rabin 设计的公钥算法。Rabin 利用了 mod N 下求平方根的困难度。破译 Rabin 公钥密码的困难度与 RSA 质因数分解 N 是相当的。





------------------------------------------------------

Reference：
  
《图解密码技术》      


> GitHub Repo：[Halfrost-Field](HTTPS://github.com/halfrost/Halfrost-Field)
> 
> Follow: [halfrost · GitHub](HTTPS://github.com/halfrost)
>
> Source: []()